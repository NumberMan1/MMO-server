// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/message.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on HeartBeatRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HeartBeatRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartBeatRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeartBeatRequestMultiError, or nil if none found.
func (m *HeartBeatRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartBeatRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HeartBeatRequestMultiError(errors)
	}

	return nil
}

// HeartBeatRequestMultiError is an error wrapping multiple validation errors
// returned by HeartBeatRequest.ValidateAll() if the designated constraints
// aren't met.
type HeartBeatRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartBeatRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartBeatRequestMultiError) AllErrors() []error { return m }

// HeartBeatRequestValidationError is the validation error returned by
// HeartBeatRequest.Validate if the designated constraints aren't met.
type HeartBeatRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartBeatRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartBeatRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartBeatRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartBeatRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartBeatRequestValidationError) ErrorName() string { return "HeartBeatRequestValidationError" }

// Error satisfies the builtin error interface
func (e HeartBeatRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartBeatRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartBeatRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartBeatRequestValidationError{}

// Validate checks the field values on HeartBeatResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HeartBeatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartBeatResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeartBeatResponseMultiError, or nil if none found.
func (m *HeartBeatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartBeatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HeartBeatResponseMultiError(errors)
	}

	return nil
}

// HeartBeatResponseMultiError is an error wrapping multiple validation errors
// returned by HeartBeatResponse.ValidateAll() if the designated constraints
// aren't met.
type HeartBeatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartBeatResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartBeatResponseMultiError) AllErrors() []error { return m }

// HeartBeatResponseValidationError is the validation error returned by
// HeartBeatResponse.Validate if the designated constraints aren't met.
type HeartBeatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartBeatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartBeatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartBeatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartBeatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartBeatResponseValidationError) ErrorName() string {
	return "HeartBeatResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HeartBeatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartBeatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartBeatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartBeatResponseValidationError{}

// Validate checks the field values on Vec3 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Vec3) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vec3 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Vec3MultiError, or nil if none found.
func (m *Vec3) ValidateAll() error {
	return m.validate(true)
}

func (m *Vec3) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	// no validation rules for Y

	// no validation rules for Z

	if len(errors) > 0 {
		return Vec3MultiError(errors)
	}

	return nil
}

// Vec3MultiError is an error wrapping multiple validation errors returned by
// Vec3.ValidateAll() if the designated constraints aren't met.
type Vec3MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Vec3MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Vec3MultiError) AllErrors() []error { return m }

// Vec3ValidationError is the validation error returned by Vec3.Validate if the
// designated constraints aren't met.
type Vec3ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Vec3ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Vec3ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Vec3ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Vec3ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Vec3ValidationError) ErrorName() string { return "Vec3ValidationError" }

// Error satisfies the builtin error interface
func (e Vec3ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVec3.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Vec3ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Vec3ValidationError{}

// Validate checks the field values on NetEntity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetEntity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetEntity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetEntityMultiError, or nil
// if none found.
func (m *NetEntity) ValidateAll() error {
	return m.validate(true)
}

func (m *NetEntity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetPosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetEntityValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetEntityValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetEntityValidationError{
				field:  "Position",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDirection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetEntityValidationError{
					field:  "Direction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetEntityValidationError{
					field:  "Direction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetEntityValidationError{
				field:  "Direction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Speed

	if len(errors) > 0 {
		return NetEntityMultiError(errors)
	}

	return nil
}

// NetEntityMultiError is an error wrapping multiple validation errors returned
// by NetEntity.ValidateAll() if the designated constraints aren't met.
type NetEntityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetEntityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetEntityMultiError) AllErrors() []error { return m }

// NetEntityValidationError is the validation error returned by
// NetEntity.Validate if the designated constraints aren't met.
type NetEntityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetEntityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetEntityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetEntityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetEntityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetEntityValidationError) ErrorName() string { return "NetEntityValidationError" }

// Error satisfies the builtin error interface
func (e NetEntityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetEntity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetEntityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetEntityValidationError{}

// Validate checks the field values on NetActor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetActor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetActor with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetActorMultiError, or nil
// if none found.
func (m *NetActor) ValidateAll() error {
	return m.validate(true)
}

func (m *NetActor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Tid

	// no validation rules for Name

	// no validation rules for Level

	// no validation rules for Exp

	// no validation rules for SpaceId

	// no validation rules for Gold

	if all {
		switch v := interface{}(m.GetEntity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetActorValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetActorValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetActorValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hp

	// no validation rules for Mp

	// no validation rules for Type

	for idx, item := range m.GetSkills() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetActorValidationError{
						field:  fmt.Sprintf("Skills[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetActorValidationError{
						field:  fmt.Sprintf("Skills[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetActorValidationError{
					field:  fmt.Sprintf("Skills[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetItemInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetActorValidationError{
					field:  "ItemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetActorValidationError{
					field:  "ItemInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetActorValidationError{
				field:  "ItemInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hpmax

	// no validation rules for Mpmax

	for idx, item := range m.GetEquipsList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetActorValidationError{
						field:  fmt.Sprintf("EquipsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetActorValidationError{
						field:  fmt.Sprintf("EquipsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetActorValidationError{
					field:  fmt.Sprintf("EquipsList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NetActorMultiError(errors)
	}

	return nil
}

// NetActorMultiError is an error wrapping multiple validation errors returned
// by NetActor.ValidateAll() if the designated constraints aren't met.
type NetActorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetActorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetActorMultiError) AllErrors() []error { return m }

// NetActorValidationError is the validation error returned by
// NetActor.Validate if the designated constraints aren't met.
type NetActorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetActorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetActorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetActorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetActorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetActorValidationError) ErrorName() string { return "NetActorValidationError" }

// Error satisfies the builtin error interface
func (e NetActorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetActor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetActorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetActorValidationError{}

// Validate checks the field values on EquipsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EquipsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EquipsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EquipsResponseMultiError,
// or nil if none found.
func (m *EquipsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EquipsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	for idx, item := range m.GetEquipsList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EquipsResponseValidationError{
						field:  fmt.Sprintf("EquipsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EquipsResponseValidationError{
						field:  fmt.Sprintf("EquipsList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EquipsResponseValidationError{
					field:  fmt.Sprintf("EquipsList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EquipsResponseMultiError(errors)
	}

	return nil
}

// EquipsResponseMultiError is an error wrapping multiple validation errors
// returned by EquipsResponse.ValidateAll() if the designated constraints
// aren't met.
type EquipsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EquipsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EquipsResponseMultiError) AllErrors() []error { return m }

// EquipsResponseValidationError is the validation error returned by
// EquipsResponse.Validate if the designated constraints aren't met.
type EquipsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EquipsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EquipsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EquipsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EquipsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EquipsResponseValidationError) ErrorName() string { return "EquipsResponseValidationError" }

// Error satisfies the builtin error interface
func (e EquipsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEquipsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EquipsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EquipsResponseValidationError{}

// Validate checks the field values on PropertyUpdate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PropertyUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyUpdate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PropertyUpdateMultiError,
// or nil if none found.
func (m *PropertyUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for Property

	if all {
		switch v := interface{}(m.GetOldValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PropertyUpdateValidationError{
					field:  "OldValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PropertyUpdateValidationError{
					field:  "OldValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PropertyUpdateValidationError{
				field:  "OldValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNewValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PropertyUpdateValidationError{
					field:  "NewValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PropertyUpdateValidationError{
					field:  "NewValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PropertyUpdateValidationError{
				field:  "NewValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PropertyUpdateMultiError(errors)
	}

	return nil
}

// PropertyUpdateMultiError is an error wrapping multiple validation errors
// returned by PropertyUpdate.ValidateAll() if the designated constraints
// aren't met.
type PropertyUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyUpdateMultiError) AllErrors() []error { return m }

// PropertyUpdateValidationError is the validation error returned by
// PropertyUpdate.Validate if the designated constraints aren't met.
type PropertyUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyUpdateValidationError) ErrorName() string { return "PropertyUpdateValidationError" }

// Error satisfies the builtin error interface
func (e PropertyUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyUpdateValidationError{}

// Validate checks the field values on PropertyUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PropertyUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PropertyUpdateResponseMultiError, or nil if none found.
func (m *PropertyUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PropertyUpdateResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PropertyUpdateResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PropertyUpdateResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PropertyUpdateResponseMultiError(errors)
	}

	return nil
}

// PropertyUpdateResponseMultiError is an error wrapping multiple validation
// errors returned by PropertyUpdateResponse.ValidateAll() if the designated
// constraints aren't met.
type PropertyUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyUpdateResponseMultiError) AllErrors() []error { return m }

// PropertyUpdateResponseValidationError is the validation error returned by
// PropertyUpdateResponse.Validate if the designated constraints aren't met.
type PropertyUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyUpdateResponseValidationError) ErrorName() string {
	return "PropertyUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PropertyUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyUpdateResponseValidationError{}

// Validate checks the field values on Damage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Damage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Damage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DamageMultiError, or nil if none found.
func (m *Damage) ValidateAll() error {
	return m.validate(true)
}

func (m *Damage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AttackerId

	// no validation rules for TargetId

	// no validation rules for SkillId

	// no validation rules for Amount

	// no validation rules for DamageType

	// no validation rules for IsCrit

	// no validation rules for IsMiss

	if len(errors) > 0 {
		return DamageMultiError(errors)
	}

	return nil
}

// DamageMultiError is an error wrapping multiple validation errors returned by
// Damage.ValidateAll() if the designated constraints aren't met.
type DamageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DamageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DamageMultiError) AllErrors() []error { return m }

// DamageValidationError is the validation error returned by Damage.Validate if
// the designated constraints aren't met.
type DamageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DamageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DamageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DamageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DamageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DamageValidationError) ErrorName() string { return "DamageValidationError" }

// Error satisfies the builtin error interface
func (e DamageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDamage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DamageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DamageValidationError{}

// Validate checks the field values on DamageResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DamageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DamageResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DamageResponseMultiError,
// or nil if none found.
func (m *DamageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DamageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DamageResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DamageResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DamageResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DamageResponseMultiError(errors)
	}

	return nil
}

// DamageResponseMultiError is an error wrapping multiple validation errors
// returned by DamageResponse.ValidateAll() if the designated constraints
// aren't met.
type DamageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DamageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DamageResponseMultiError) AllErrors() []error { return m }

// DamageResponseValidationError is the validation error returned by
// DamageResponse.Validate if the designated constraints aren't met.
type DamageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DamageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DamageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DamageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DamageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DamageResponseValidationError) ErrorName() string { return "DamageResponseValidationError" }

// Error satisfies the builtin error interface
func (e DamageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDamageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DamageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DamageResponseValidationError{}

// Validate checks the field values on ChatRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChatRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChatRequestMultiError, or
// nil if none found.
func (m *ChatRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TextValue

	if len(errors) > 0 {
		return ChatRequestMultiError(errors)
	}

	return nil
}

// ChatRequestMultiError is an error wrapping multiple validation errors
// returned by ChatRequest.ValidateAll() if the designated constraints aren't met.
type ChatRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatRequestMultiError) AllErrors() []error { return m }

// ChatRequestValidationError is the validation error returned by
// ChatRequest.Validate if the designated constraints aren't met.
type ChatRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatRequestValidationError) ErrorName() string { return "ChatRequestValidationError" }

// Error satisfies the builtin error interface
func (e ChatRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatRequestValidationError{}

// Validate checks the field values on ChatResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChatResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChatResponseMultiError, or
// nil if none found.
func (m *ChatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SenderId

	// no validation rules for TextValue

	if len(errors) > 0 {
		return ChatResponseMultiError(errors)
	}

	return nil
}

// ChatResponseMultiError is an error wrapping multiple validation errors
// returned by ChatResponse.ValidateAll() if the designated constraints aren't met.
type ChatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChatResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChatResponseMultiError) AllErrors() []error { return m }

// ChatResponseValidationError is the validation error returned by
// ChatResponse.Validate if the designated constraints aren't met.
type ChatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChatResponseValidationError) ErrorName() string { return "ChatResponseValidationError" }

// Error satisfies the builtin error interface
func (e ChatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChatResponseValidationError{}

// Validate checks the field values on SkillInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SkillInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SkillInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SkillInfoMultiError, or nil
// if none found.
func (m *SkillInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SkillInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return SkillInfoMultiError(errors)
	}

	return nil
}

// SkillInfoMultiError is an error wrapping multiple validation errors returned
// by SkillInfo.ValidateAll() if the designated constraints aren't met.
type SkillInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SkillInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SkillInfoMultiError) AllErrors() []error { return m }

// SkillInfoValidationError is the validation error returned by
// SkillInfo.Validate if the designated constraints aren't met.
type SkillInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SkillInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SkillInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SkillInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SkillInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SkillInfoValidationError) ErrorName() string { return "SkillInfoValidationError" }

// Error satisfies the builtin error interface
func (e SkillInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSkillInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SkillInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SkillInfoValidationError{}

// Validate checks the field values on CastInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CastInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CastInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CastInfoMultiError, or nil
// if none found.
func (m *CastInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CastInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CasterId

	// no validation rules for SkillId

	// no validation rules for TargetId

	if all {
		switch v := interface{}(m.GetTargetLoc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CastInfoValidationError{
					field:  "TargetLoc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CastInfoValidationError{
					field:  "TargetLoc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetLoc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CastInfoValidationError{
				field:  "TargetLoc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CastInfoMultiError(errors)
	}

	return nil
}

// CastInfoMultiError is an error wrapping multiple validation errors returned
// by CastInfo.ValidateAll() if the designated constraints aren't met.
type CastInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CastInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CastInfoMultiError) AllErrors() []error { return m }

// CastInfoValidationError is the validation error returned by
// CastInfo.Validate if the designated constraints aren't met.
type CastInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CastInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CastInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CastInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CastInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CastInfoValidationError) ErrorName() string { return "CastInfoValidationError" }

// Error satisfies the builtin error interface
func (e CastInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCastInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CastInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CastInfoValidationError{}

// Validate checks the field values on SpellRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpellRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpellRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpellRequestMultiError, or
// nil if none found.
func (m *SpellRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SpellRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpellRequestValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpellRequestValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpellRequestValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpellRequestMultiError(errors)
	}

	return nil
}

// SpellRequestMultiError is an error wrapping multiple validation errors
// returned by SpellRequest.ValidateAll() if the designated constraints aren't met.
type SpellRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpellRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpellRequestMultiError) AllErrors() []error { return m }

// SpellRequestValidationError is the validation error returned by
// SpellRequest.Validate if the designated constraints aren't met.
type SpellRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpellRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpellRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpellRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpellRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpellRequestValidationError) ErrorName() string { return "SpellRequestValidationError" }

// Error satisfies the builtin error interface
func (e SpellRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpellRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpellRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpellRequestValidationError{}

// Validate checks the field values on SpellFailResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpellFailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpellFailResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpellFailResponseMultiError, or nil if none found.
func (m *SpellFailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpellFailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CasterId

	// no validation rules for SkillId

	// no validation rules for Reason

	if len(errors) > 0 {
		return SpellFailResponseMultiError(errors)
	}

	return nil
}

// SpellFailResponseMultiError is an error wrapping multiple validation errors
// returned by SpellFailResponse.ValidateAll() if the designated constraints
// aren't met.
type SpellFailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpellFailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpellFailResponseMultiError) AllErrors() []error { return m }

// SpellFailResponseValidationError is the validation error returned by
// SpellFailResponse.Validate if the designated constraints aren't met.
type SpellFailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpellFailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpellFailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpellFailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpellFailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpellFailResponseValidationError) ErrorName() string {
	return "SpellFailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpellFailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpellFailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpellFailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpellFailResponseValidationError{}

// Validate checks the field values on SpellResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpellResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpellResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpellResponseMultiError, or
// nil if none found.
func (m *SpellResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpellResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCastList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpellResponseValidationError{
						field:  fmt.Sprintf("CastList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpellResponseValidationError{
						field:  fmt.Sprintf("CastList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpellResponseValidationError{
					field:  fmt.Sprintf("CastList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpellResponseMultiError(errors)
	}

	return nil
}

// SpellResponseMultiError is an error wrapping multiple validation errors
// returned by SpellResponse.ValidateAll() if the designated constraints
// aren't met.
type SpellResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpellResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpellResponseMultiError) AllErrors() []error { return m }

// SpellResponseValidationError is the validation error returned by
// SpellResponse.Validate if the designated constraints aren't met.
type SpellResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpellResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpellResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpellResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpellResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpellResponseValidationError) ErrorName() string { return "SpellResponseValidationError" }

// Error satisfies the builtin error interface
func (e SpellResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpellResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpellResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpellResponseValidationError{}

// Validate checks the field values on ReviveRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReviveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReviveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReviveRequestMultiError, or
// nil if none found.
func (m *ReviveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReviveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	if len(errors) > 0 {
		return ReviveRequestMultiError(errors)
	}

	return nil
}

// ReviveRequestMultiError is an error wrapping multiple validation errors
// returned by ReviveRequest.ValidateAll() if the designated constraints
// aren't met.
type ReviveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviveRequestMultiError) AllErrors() []error { return m }

// ReviveRequestValidationError is the validation error returned by
// ReviveRequest.Validate if the designated constraints aren't met.
type ReviveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviveRequestValidationError) ErrorName() string { return "ReviveRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReviveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviveRequestValidationError{}

// Validate checks the field values on SpaceEnterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpaceEnterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceEnterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceEnterResponseMultiError, or nil if none found.
func (m *SpaceEnterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceEnterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCharacter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpaceEnterResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpaceEnterResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCharacter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpaceEnterResponseValidationError{
				field:  "Character",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpaceEnterResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpaceEnterResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpaceEnterResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpaceEnterResponseMultiError(errors)
	}

	return nil
}

// SpaceEnterResponseMultiError is an error wrapping multiple validation errors
// returned by SpaceEnterResponse.ValidateAll() if the designated constraints
// aren't met.
type SpaceEnterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceEnterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceEnterResponseMultiError) AllErrors() []error { return m }

// SpaceEnterResponseValidationError is the validation error returned by
// SpaceEnterResponse.Validate if the designated constraints aren't met.
type SpaceEnterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceEnterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceEnterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceEnterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceEnterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceEnterResponseValidationError) ErrorName() string {
	return "SpaceEnterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpaceEnterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceEnterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceEnterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceEnterResponseValidationError{}

// Validate checks the field values on NetEntitySync with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NetEntitySync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetEntitySync with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetEntitySyncMultiError, or
// nil if none found.
func (m *NetEntitySync) ValidateAll() error {
	return m.validate(true)
}

func (m *NetEntitySync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NetEntitySyncValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NetEntitySyncValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NetEntitySyncValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for Force

	if len(errors) > 0 {
		return NetEntitySyncMultiError(errors)
	}

	return nil
}

// NetEntitySyncMultiError is an error wrapping multiple validation errors
// returned by NetEntitySync.ValidateAll() if the designated constraints
// aren't met.
type NetEntitySyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetEntitySyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetEntitySyncMultiError) AllErrors() []error { return m }

// NetEntitySyncValidationError is the validation error returned by
// NetEntitySync.Validate if the designated constraints aren't met.
type NetEntitySyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetEntitySyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetEntitySyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetEntitySyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetEntitySyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetEntitySyncValidationError) ErrorName() string { return "NetEntitySyncValidationError" }

// Error satisfies the builtin error interface
func (e NetEntitySyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetEntitySync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetEntitySyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetEntitySyncValidationError{}

// Validate checks the field values on SpaceEntitySyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpaceEntitySyncRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceEntitySyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceEntitySyncRequestMultiError, or nil if none found.
func (m *SpaceEntitySyncRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceEntitySyncRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntitySync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpaceEntitySyncRequestValidationError{
					field:  "EntitySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpaceEntitySyncRequestValidationError{
					field:  "EntitySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntitySync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpaceEntitySyncRequestValidationError{
				field:  "EntitySync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpaceEntitySyncRequestMultiError(errors)
	}

	return nil
}

// SpaceEntitySyncRequestMultiError is an error wrapping multiple validation
// errors returned by SpaceEntitySyncRequest.ValidateAll() if the designated
// constraints aren't met.
type SpaceEntitySyncRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceEntitySyncRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceEntitySyncRequestMultiError) AllErrors() []error { return m }

// SpaceEntitySyncRequestValidationError is the validation error returned by
// SpaceEntitySyncRequest.Validate if the designated constraints aren't met.
type SpaceEntitySyncRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceEntitySyncRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceEntitySyncRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceEntitySyncRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceEntitySyncRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceEntitySyncRequestValidationError) ErrorName() string {
	return "SpaceEntitySyncRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SpaceEntitySyncRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceEntitySyncRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceEntitySyncRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceEntitySyncRequestValidationError{}

// Validate checks the field values on SpaceEntitySyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpaceEntitySyncResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceEntitySyncResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceEntitySyncResponseMultiError, or nil if none found.
func (m *SpaceEntitySyncResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceEntitySyncResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntitySync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpaceEntitySyncResponseValidationError{
					field:  "EntitySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpaceEntitySyncResponseValidationError{
					field:  "EntitySync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntitySync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpaceEntitySyncResponseValidationError{
				field:  "EntitySync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpaceEntitySyncResponseMultiError(errors)
	}

	return nil
}

// SpaceEntitySyncResponseMultiError is an error wrapping multiple validation
// errors returned by SpaceEntitySyncResponse.ValidateAll() if the designated
// constraints aren't met.
type SpaceEntitySyncResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceEntitySyncResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceEntitySyncResponseMultiError) AllErrors() []error { return m }

// SpaceEntitySyncResponseValidationError is the validation error returned by
// SpaceEntitySyncResponse.Validate if the designated constraints aren't met.
type SpaceEntitySyncResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceEntitySyncResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceEntitySyncResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceEntitySyncResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceEntitySyncResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceEntitySyncResponseValidationError) ErrorName() string {
	return "SpaceEntitySyncResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpaceEntitySyncResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceEntitySyncResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceEntitySyncResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceEntitySyncResponseValidationError{}

// Validate checks the field values on GameEnterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameEnterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameEnterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameEnterRequestMultiError, or nil if none found.
func (m *GameEnterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GameEnterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	if len(errors) > 0 {
		return GameEnterRequestMultiError(errors)
	}

	return nil
}

// GameEnterRequestMultiError is an error wrapping multiple validation errors
// returned by GameEnterRequest.ValidateAll() if the designated constraints
// aren't met.
type GameEnterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameEnterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameEnterRequestMultiError) AllErrors() []error { return m }

// GameEnterRequestValidationError is the validation error returned by
// GameEnterRequest.Validate if the designated constraints aren't met.
type GameEnterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameEnterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameEnterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameEnterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameEnterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameEnterRequestValidationError) ErrorName() string { return "GameEnterRequestValidationError" }

// Error satisfies the builtin error interface
func (e GameEnterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameEnterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameEnterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameEnterRequestValidationError{}

// Validate checks the field values on GameEnterResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GameEnterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GameEnterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GameEnterResponseMultiError, or nil if none found.
func (m *GameEnterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GameEnterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	if all {
		switch v := interface{}(m.GetEntity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameEnterResponseValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameEnterResponseValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameEnterResponseValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCharacter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GameEnterResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GameEnterResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCharacter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GameEnterResponseValidationError{
				field:  "Character",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GameEnterResponseMultiError(errors)
	}

	return nil
}

// GameEnterResponseMultiError is an error wrapping multiple validation errors
// returned by GameEnterResponse.ValidateAll() if the designated constraints
// aren't met.
type GameEnterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GameEnterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GameEnterResponseMultiError) AllErrors() []error { return m }

// GameEnterResponseValidationError is the validation error returned by
// GameEnterResponse.Validate if the designated constraints aren't met.
type GameEnterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GameEnterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GameEnterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GameEnterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GameEnterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GameEnterResponseValidationError) ErrorName() string {
	return "GameEnterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GameEnterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGameEnterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GameEnterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GameEnterResponseValidationError{}

// Validate checks the field values on SpaceCharactersEnterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpaceCharactersEnterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceCharactersEnterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceCharactersEnterResponseMultiError, or nil if none found.
func (m *SpaceCharactersEnterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceCharactersEnterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpaceId

	for idx, item := range m.GetCharacterList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpaceCharactersEnterResponseValidationError{
						field:  fmt.Sprintf("CharacterList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpaceCharactersEnterResponseValidationError{
						field:  fmt.Sprintf("CharacterList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpaceCharactersEnterResponseValidationError{
					field:  fmt.Sprintf("CharacterList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpaceCharactersEnterResponseMultiError(errors)
	}

	return nil
}

// SpaceCharactersEnterResponseMultiError is an error wrapping multiple
// validation errors returned by SpaceCharactersEnterResponse.ValidateAll() if
// the designated constraints aren't met.
type SpaceCharactersEnterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceCharactersEnterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceCharactersEnterResponseMultiError) AllErrors() []error { return m }

// SpaceCharactersEnterResponseValidationError is the validation error returned
// by SpaceCharactersEnterResponse.Validate if the designated constraints
// aren't met.
type SpaceCharactersEnterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceCharactersEnterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceCharactersEnterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceCharactersEnterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceCharactersEnterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceCharactersEnterResponseValidationError) ErrorName() string {
	return "SpaceCharactersEnterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpaceCharactersEnterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceCharactersEnterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceCharactersEnterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceCharactersEnterResponseValidationError{}

// Validate checks the field values on SpaceCharacterLeaveResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpaceCharacterLeaveResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceCharacterLeaveResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceCharacterLeaveResponseMultiError, or nil if none found.
func (m *SpaceCharacterLeaveResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceCharacterLeaveResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	if len(errors) > 0 {
		return SpaceCharacterLeaveResponseMultiError(errors)
	}

	return nil
}

// SpaceCharacterLeaveResponseMultiError is an error wrapping multiple
// validation errors returned by SpaceCharacterLeaveResponse.ValidateAll() if
// the designated constraints aren't met.
type SpaceCharacterLeaveResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceCharacterLeaveResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceCharacterLeaveResponseMultiError) AllErrors() []error { return m }

// SpaceCharacterLeaveResponseValidationError is the validation error returned
// by SpaceCharacterLeaveResponse.Validate if the designated constraints
// aren't met.
type SpaceCharacterLeaveResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceCharacterLeaveResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceCharacterLeaveResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceCharacterLeaveResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceCharacterLeaveResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceCharacterLeaveResponseValidationError) ErrorName() string {
	return "SpaceCharacterLeaveResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpaceCharacterLeaveResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceCharacterLeaveResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceCharacterLeaveResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceCharacterLeaveResponseValidationError{}

// Validate checks the field values on UserRegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserRegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserRegisterRequestMultiError, or nil if none found.
func (m *UserRegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UserRegisterRequestMultiError(errors)
	}

	return nil
}

// UserRegisterRequestMultiError is an error wrapping multiple validation
// errors returned by UserRegisterRequest.ValidateAll() if the designated
// constraints aren't met.
type UserRegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRegisterRequestMultiError) AllErrors() []error { return m }

// UserRegisterRequestValidationError is the validation error returned by
// UserRegisterRequest.Validate if the designated constraints aren't met.
type UserRegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRegisterRequestValidationError) ErrorName() string {
	return "UserRegisterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UserRegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRegisterRequestValidationError{}

// Validate checks the field values on UserRegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserRegisterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRegisterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserRegisterResponseMultiError, or nil if none found.
func (m *UserRegisterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRegisterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return UserRegisterResponseMultiError(errors)
	}

	return nil
}

// UserRegisterResponseMultiError is an error wrapping multiple validation
// errors returned by UserRegisterResponse.ValidateAll() if the designated
// constraints aren't met.
type UserRegisterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRegisterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRegisterResponseMultiError) AllErrors() []error { return m }

// UserRegisterResponseValidationError is the validation error returned by
// UserRegisterResponse.Validate if the designated constraints aren't met.
type UserRegisterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRegisterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRegisterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRegisterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRegisterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRegisterResponseValidationError) ErrorName() string {
	return "UserRegisterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserRegisterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRegisterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRegisterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRegisterResponseValidationError{}

// Validate checks the field values on UserLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLoginRequestMultiError, or nil if none found.
func (m *UserLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return UserLoginRequestMultiError(errors)
	}

	return nil
}

// UserLoginRequestMultiError is an error wrapping multiple validation errors
// returned by UserLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type UserLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginRequestMultiError) AllErrors() []error { return m }

// UserLoginRequestValidationError is the validation error returned by
// UserLoginRequest.Validate if the designated constraints aren't met.
type UserLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginRequestValidationError) ErrorName() string { return "UserLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e UserLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginRequestValidationError{}

// Validate checks the field values on UserLoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserLoginResponseMultiError, or nil if none found.
func (m *UserLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for SessionId

	if len(errors) > 0 {
		return UserLoginResponseMultiError(errors)
	}

	return nil
}

// UserLoginResponseMultiError is an error wrapping multiple validation errors
// returned by UserLoginResponse.ValidateAll() if the designated constraints
// aren't met.
type UserLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserLoginResponseMultiError) AllErrors() []error { return m }

// UserLoginResponseValidationError is the validation error returned by
// UserLoginResponse.Validate if the designated constraints aren't met.
type UserLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserLoginResponseValidationError) ErrorName() string {
	return "UserLoginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserLoginResponseValidationError{}

// Validate checks the field values on EntitySyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EntitySyncResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntitySyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntitySyncResponseMultiError, or nil if none found.
func (m *EntitySyncResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EntitySyncResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitySyncResponseValidationError{
						field:  fmt.Sprintf("EntityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitySyncResponseValidationError{
						field:  fmt.Sprintf("EntityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitySyncResponseValidationError{
					field:  fmt.Sprintf("EntityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EntitySyncResponseMultiError(errors)
	}

	return nil
}

// EntitySyncResponseMultiError is an error wrapping multiple validation errors
// returned by EntitySyncResponse.ValidateAll() if the designated constraints
// aren't met.
type EntitySyncResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntitySyncResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntitySyncResponseMultiError) AllErrors() []error { return m }

// EntitySyncResponseValidationError is the validation error returned by
// EntitySyncResponse.Validate if the designated constraints aren't met.
type EntitySyncResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntitySyncResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntitySyncResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntitySyncResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntitySyncResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntitySyncResponseValidationError) ErrorName() string {
	return "EntitySyncResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EntitySyncResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntitySyncResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntitySyncResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntitySyncResponseValidationError{}

// Validate checks the field values on EntityEnterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EntityEnterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntityEnterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntityEnterResponseMultiError, or nil if none found.
func (m *EntityEnterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EntityEnterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntityEnterResponseValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntityEnterResponseValidationError{
					field:  "Entity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntityEnterResponseValidationError{
				field:  "Entity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EntityEnterResponseMultiError(errors)
	}

	return nil
}

// EntityEnterResponseMultiError is an error wrapping multiple validation
// errors returned by EntityEnterResponse.ValidateAll() if the designated
// constraints aren't met.
type EntityEnterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntityEnterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntityEnterResponseMultiError) AllErrors() []error { return m }

// EntityEnterResponseValidationError is the validation error returned by
// EntityEnterResponse.Validate if the designated constraints aren't met.
type EntityEnterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntityEnterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntityEnterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntityEnterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntityEnterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntityEnterResponseValidationError) ErrorName() string {
	return "EntityEnterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EntityEnterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntityEnterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntityEnterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntityEnterResponseValidationError{}

// Validate checks the field values on CharacterCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterCreateRequestMultiError, or nil if none found.
func (m *CharacterCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for JobType

	if len(errors) > 0 {
		return CharacterCreateRequestMultiError(errors)
	}

	return nil
}

// CharacterCreateRequestMultiError is an error wrapping multiple validation
// errors returned by CharacterCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type CharacterCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterCreateRequestMultiError) AllErrors() []error { return m }

// CharacterCreateRequestValidationError is the validation error returned by
// CharacterCreateRequest.Validate if the designated constraints aren't met.
type CharacterCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterCreateRequestValidationError) ErrorName() string {
	return "CharacterCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterCreateRequestValidationError{}

// Validate checks the field values on ChracterCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChracterCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChracterCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChracterCreateResponseMultiError, or nil if none found.
func (m *ChracterCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ChracterCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetCharacter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChracterCreateResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChracterCreateResponseValidationError{
					field:  "Character",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCharacter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChracterCreateResponseValidationError{
				field:  "Character",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChracterCreateResponseMultiError(errors)
	}

	return nil
}

// ChracterCreateResponseMultiError is an error wrapping multiple validation
// errors returned by ChracterCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type ChracterCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChracterCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChracterCreateResponseMultiError) AllErrors() []error { return m }

// ChracterCreateResponseValidationError is the validation error returned by
// ChracterCreateResponse.Validate if the designated constraints aren't met.
type ChracterCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChracterCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChracterCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChracterCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChracterCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChracterCreateResponseValidationError) ErrorName() string {
	return "ChracterCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ChracterCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChracterCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChracterCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChracterCreateResponseValidationError{}

// Validate checks the field values on CharacterListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterListRequestMultiError, or nil if none found.
func (m *CharacterListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CharacterListRequestMultiError(errors)
	}

	return nil
}

// CharacterListRequestMultiError is an error wrapping multiple validation
// errors returned by CharacterListRequest.ValidateAll() if the designated
// constraints aren't met.
type CharacterListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterListRequestMultiError) AllErrors() []error { return m }

// CharacterListRequestValidationError is the validation error returned by
// CharacterListRequest.Validate if the designated constraints aren't met.
type CharacterListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterListRequestValidationError) ErrorName() string {
	return "CharacterListRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterListRequestValidationError{}

// Validate checks the field values on CharacterListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterListResponseMultiError, or nil if none found.
func (m *CharacterListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCharacterList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CharacterListResponseValidationError{
						field:  fmt.Sprintf("CharacterList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CharacterListResponseValidationError{
						field:  fmt.Sprintf("CharacterList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CharacterListResponseValidationError{
					field:  fmt.Sprintf("CharacterList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CharacterListResponseMultiError(errors)
	}

	return nil
}

// CharacterListResponseMultiError is an error wrapping multiple validation
// errors returned by CharacterListResponse.ValidateAll() if the designated
// constraints aren't met.
type CharacterListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterListResponseMultiError) AllErrors() []error { return m }

// CharacterListResponseValidationError is the validation error returned by
// CharacterListResponse.Validate if the designated constraints aren't met.
type CharacterListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterListResponseValidationError) ErrorName() string {
	return "CharacterListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterListResponseValidationError{}

// Validate checks the field values on CharacterDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterDeleteRequestMultiError, or nil if none found.
func (m *CharacterDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CharacterId

	if len(errors) > 0 {
		return CharacterDeleteRequestMultiError(errors)
	}

	return nil
}

// CharacterDeleteRequestMultiError is an error wrapping multiple validation
// errors returned by CharacterDeleteRequest.ValidateAll() if the designated
// constraints aren't met.
type CharacterDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterDeleteRequestMultiError) AllErrors() []error { return m }

// CharacterDeleteRequestValidationError is the validation error returned by
// CharacterDeleteRequest.Validate if the designated constraints aren't met.
type CharacterDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterDeleteRequestValidationError) ErrorName() string {
	return "CharacterDeleteRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterDeleteRequestValidationError{}

// Validate checks the field values on CharacterDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CharacterDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharacterDeleteResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CharacterDeleteResponseMultiError, or nil if none found.
func (m *CharacterDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CharacterDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return CharacterDeleteResponseMultiError(errors)
	}

	return nil
}

// CharacterDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by CharacterDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type CharacterDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharacterDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharacterDeleteResponseMultiError) AllErrors() []error { return m }

// CharacterDeleteResponseValidationError is the validation error returned by
// CharacterDeleteResponse.Validate if the designated constraints aren't met.
type CharacterDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharacterDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharacterDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharacterDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharacterDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharacterDeleteResponseValidationError) ErrorName() string {
	return "CharacterDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CharacterDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharacterDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharacterDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharacterDeleteResponseValidationError{}

// Validate checks the field values on EquipData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EquipData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EquipData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EquipDataMultiError, or nil
// if none found.
func (m *EquipData) ValidateAll() error {
	return m.validate(true)
}

func (m *EquipData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EquipDataMultiError(errors)
	}

	return nil
}

// EquipDataMultiError is an error wrapping multiple validation errors returned
// by EquipData.ValidateAll() if the designated constraints aren't met.
type EquipDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EquipDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EquipDataMultiError) AllErrors() []error { return m }

// EquipDataValidationError is the validation error returned by
// EquipData.Validate if the designated constraints aren't met.
type EquipDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EquipDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EquipDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EquipDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EquipDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EquipDataValidationError) ErrorName() string { return "EquipDataValidationError" }

// Error satisfies the builtin error interface
func (e EquipDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEquipData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EquipDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EquipDataValidationError{}

// Validate checks the field values on ItemInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItemInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItemInfoMultiError, or nil
// if none found.
func (m *ItemInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ItemId

	// no validation rules for Amount

	// no validation rules for Position

	if all {
		switch v := interface{}(m.GetEquipData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemInfoValidationError{
					field:  "EquipData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemInfoValidationError{
					field:  "EquipData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEquipData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemInfoValidationError{
				field:  "EquipData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ItemInfoMultiError(errors)
	}

	return nil
}

// ItemInfoMultiError is an error wrapping multiple validation errors returned
// by ItemInfo.ValidateAll() if the designated constraints aren't met.
type ItemInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemInfoMultiError) AllErrors() []error { return m }

// ItemInfoValidationError is the validation error returned by
// ItemInfo.Validate if the designated constraints aren't met.
type ItemInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemInfoValidationError) ErrorName() string { return "ItemInfoValidationError" }

// Error satisfies the builtin error interface
func (e ItemInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemInfoValidationError{}

// Validate checks the field values on ItemUpdate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItemUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemUpdate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItemUpdateMultiError, or
// nil if none found.
func (m *ItemUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemUpdateValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemUpdateValidationError{
					field:  "Item",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemUpdateValidationError{
				field:  "Item",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ItemUpdateMultiError(errors)
	}

	return nil
}

// ItemUpdateMultiError is an error wrapping multiple validation errors
// returned by ItemUpdate.ValidateAll() if the designated constraints aren't met.
type ItemUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemUpdateMultiError) AllErrors() []error { return m }

// ItemUpdateValidationError is the validation error returned by
// ItemUpdate.Validate if the designated constraints aren't met.
type ItemUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemUpdateValidationError) ErrorName() string { return "ItemUpdateValidationError" }

// Error satisfies the builtin error interface
func (e ItemUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemUpdateValidationError{}

// Validate checks the field values on InventoryInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InventoryInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InventoryInfoMultiError, or
// nil if none found.
func (m *InventoryInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Capacity

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InventoryInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InventoryInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InventoryInfoValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InventoryInfoMultiError(errors)
	}

	return nil
}

// InventoryInfoMultiError is an error wrapping multiple validation errors
// returned by InventoryInfo.ValidateAll() if the designated constraints
// aren't met.
type InventoryInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryInfoMultiError) AllErrors() []error { return m }

// InventoryInfoValidationError is the validation error returned by
// InventoryInfo.Validate if the designated constraints aren't met.
type InventoryInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryInfoValidationError) ErrorName() string { return "InventoryInfoValidationError" }

// Error satisfies the builtin error interface
func (e InventoryInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryInfoValidationError{}

// Validate checks the field values on PickupItemRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PickupItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PickupItemRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PickupItemRequestMultiError, or nil if none found.
func (m *PickupItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PickupItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	if len(errors) > 0 {
		return PickupItemRequestMultiError(errors)
	}

	return nil
}

// PickupItemRequestMultiError is an error wrapping multiple validation errors
// returned by PickupItemRequest.ValidateAll() if the designated constraints
// aren't met.
type PickupItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PickupItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PickupItemRequestMultiError) AllErrors() []error { return m }

// PickupItemRequestValidationError is the validation error returned by
// PickupItemRequest.Validate if the designated constraints aren't met.
type PickupItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PickupItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PickupItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PickupItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PickupItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PickupItemRequestValidationError) ErrorName() string {
	return "PickupItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PickupItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPickupItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PickupItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PickupItemRequestValidationError{}

// Validate checks the field values on InventoryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InventoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryRequestMultiError, or nil if none found.
func (m *InventoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for QueryKnapsack

	// no validation rules for QueryWarehouse

	// no validation rules for QueryEquipment

	if len(errors) > 0 {
		return InventoryRequestMultiError(errors)
	}

	return nil
}

// InventoryRequestMultiError is an error wrapping multiple validation errors
// returned by InventoryRequest.ValidateAll() if the designated constraints
// aren't met.
type InventoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryRequestMultiError) AllErrors() []error { return m }

// InventoryRequestValidationError is the validation error returned by
// InventoryRequest.Validate if the designated constraints aren't met.
type InventoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryRequestValidationError) ErrorName() string { return "InventoryRequestValidationError" }

// Error satisfies the builtin error interface
func (e InventoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryRequestValidationError{}

// Validate checks the field values on InventoryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InventoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryResponseMultiError, or nil if none found.
func (m *InventoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	if all {
		switch v := interface{}(m.GetKnapsackInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "KnapsackInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "KnapsackInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKnapsackInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryResponseValidationError{
				field:  "KnapsackInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWarehouseInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "WarehouseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "WarehouseInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWarehouseInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryResponseValidationError{
				field:  "WarehouseInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEquipmentInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "EquipmentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryResponseValidationError{
					field:  "EquipmentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEquipmentInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryResponseValidationError{
				field:  "EquipmentInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryResponseMultiError(errors)
	}

	return nil
}

// InventoryResponseMultiError is an error wrapping multiple validation errors
// returned by InventoryResponse.ValidateAll() if the designated constraints
// aren't met.
type InventoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryResponseMultiError) AllErrors() []error { return m }

// InventoryResponseValidationError is the validation error returned by
// InventoryResponse.Validate if the designated constraints aren't met.
type InventoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryResponseValidationError) ErrorName() string {
	return "InventoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryResponseValidationError{}

// Validate checks the field values on ItemPlacementRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ItemPlacementRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemPlacementRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ItemPlacementRequestMultiError, or nil if none found.
func (m *ItemPlacementRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemPlacementRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for OriginIndex

	// no validation rules for TargetIndex

	if len(errors) > 0 {
		return ItemPlacementRequestMultiError(errors)
	}

	return nil
}

// ItemPlacementRequestMultiError is an error wrapping multiple validation
// errors returned by ItemPlacementRequest.ValidateAll() if the designated
// constraints aren't met.
type ItemPlacementRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemPlacementRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemPlacementRequestMultiError) AllErrors() []error { return m }

// ItemPlacementRequestValidationError is the validation error returned by
// ItemPlacementRequest.Validate if the designated constraints aren't met.
type ItemPlacementRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemPlacementRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemPlacementRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemPlacementRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemPlacementRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemPlacementRequestValidationError) ErrorName() string {
	return "ItemPlacementRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ItemPlacementRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemPlacementRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemPlacementRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemPlacementRequestValidationError{}

// Validate checks the field values on ItemDiscardRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ItemDiscardRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemDiscardRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ItemDiscardRequestMultiError, or nil if none found.
func (m *ItemDiscardRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemDiscardRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for SlotIndex

	// no validation rules for Count

	if len(errors) > 0 {
		return ItemDiscardRequestMultiError(errors)
	}

	return nil
}

// ItemDiscardRequestMultiError is an error wrapping multiple validation errors
// returned by ItemDiscardRequest.ValidateAll() if the designated constraints
// aren't met.
type ItemDiscardRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemDiscardRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemDiscardRequestMultiError) AllErrors() []error { return m }

// ItemDiscardRequestValidationError is the validation error returned by
// ItemDiscardRequest.Validate if the designated constraints aren't met.
type ItemDiscardRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemDiscardRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemDiscardRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemDiscardRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemDiscardRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemDiscardRequestValidationError) ErrorName() string {
	return "ItemDiscardRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ItemDiscardRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemDiscardRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemDiscardRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemDiscardRequestValidationError{}

// Validate checks the field values on ItemUseRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItemUseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemUseRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItemUseRequestMultiError,
// or nil if none found.
func (m *ItemUseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemUseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for SlotIndex

	if len(errors) > 0 {
		return ItemUseRequestMultiError(errors)
	}

	return nil
}

// ItemUseRequestMultiError is an error wrapping multiple validation errors
// returned by ItemUseRequest.ValidateAll() if the designated constraints
// aren't met.
type ItemUseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemUseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemUseRequestMultiError) AllErrors() []error { return m }

// ItemUseRequestValidationError is the validation error returned by
// ItemUseRequest.Validate if the designated constraints aren't met.
type ItemUseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemUseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemUseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemUseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemUseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemUseRequestValidationError) ErrorName() string { return "ItemUseRequestValidationError" }

// Error satisfies the builtin error interface
func (e ItemUseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemUseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemUseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemUseRequestValidationError{}

// Validate checks the field values on ItemAttachRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ItemAttachRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemAttachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ItemAttachRequestMultiError, or nil if none found.
func (m *ItemAttachRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemAttachRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for SlotIndex

	if len(errors) > 0 {
		return ItemAttachRequestMultiError(errors)
	}

	return nil
}

// ItemAttachRequestMultiError is an error wrapping multiple validation errors
// returned by ItemAttachRequest.ValidateAll() if the designated constraints
// aren't met.
type ItemAttachRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemAttachRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemAttachRequestMultiError) AllErrors() []error { return m }

// ItemAttachRequestValidationError is the validation error returned by
// ItemAttachRequest.Validate if the designated constraints aren't met.
type ItemAttachRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemAttachRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemAttachRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemAttachRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemAttachRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemAttachRequestValidationError) ErrorName() string {
	return "ItemAttachRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ItemAttachRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemAttachRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemAttachRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemAttachRequestValidationError{}

// Validate checks the field values on ItemDetachRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ItemDetachRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItemDetachRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ItemDetachRequestMultiError, or nil if none found.
func (m *ItemDetachRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ItemDetachRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EntityId

	// no validation rules for EquipsType

	if len(errors) > 0 {
		return ItemDetachRequestMultiError(errors)
	}

	return nil
}

// ItemDetachRequestMultiError is an error wrapping multiple validation errors
// returned by ItemDetachRequest.ValidateAll() if the designated constraints
// aren't met.
type ItemDetachRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemDetachRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemDetachRequestMultiError) AllErrors() []error { return m }

// ItemDetachRequestValidationError is the validation error returned by
// ItemDetachRequest.Validate if the designated constraints aren't met.
type ItemDetachRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemDetachRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemDetachRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemDetachRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemDetachRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemDetachRequestValidationError) ErrorName() string {
	return "ItemDetachRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ItemDetachRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItemDetachRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemDetachRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemDetachRequestValidationError{}

// Validate checks the field values on ReconnectRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReconnectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconnectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconnectRequestMultiError, or nil if none found.
func (m *ReconnectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconnectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SessionId

	if len(errors) > 0 {
		return ReconnectRequestMultiError(errors)
	}

	return nil
}

// ReconnectRequestMultiError is an error wrapping multiple validation errors
// returned by ReconnectRequest.ValidateAll() if the designated constraints
// aren't met.
type ReconnectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconnectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconnectRequestMultiError) AllErrors() []error { return m }

// ReconnectRequestValidationError is the validation error returned by
// ReconnectRequest.Validate if the designated constraints aren't met.
type ReconnectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconnectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconnectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconnectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconnectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconnectRequestValidationError) ErrorName() string { return "ReconnectRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReconnectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconnectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconnectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconnectRequestValidationError{}

// Validate checks the field values on ReconnectResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReconnectResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconnectResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconnectResponseMultiError, or nil if none found.
func (m *ReconnectResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconnectResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for EntityId

	if len(errors) > 0 {
		return ReconnectResponseMultiError(errors)
	}

	return nil
}

// ReconnectResponseMultiError is an error wrapping multiple validation errors
// returned by ReconnectResponse.ValidateAll() if the designated constraints
// aren't met.
type ReconnectResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconnectResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconnectResponseMultiError) AllErrors() []error { return m }

// ReconnectResponseValidationError is the validation error returned by
// ReconnectResponse.Validate if the designated constraints aren't met.
type ReconnectResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconnectResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconnectResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconnectResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconnectResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconnectResponseValidationError) ErrorName() string {
	return "ReconnectResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReconnectResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconnectResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconnectResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconnectResponseValidationError{}

// Validate checks the field values on ExitRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExitRequestMultiError, or
// nil if none found.
func (m *ExitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExitRequestMultiError(errors)
	}

	return nil
}

// ExitRequestMultiError is an error wrapping multiple validation errors
// returned by ExitRequest.ValidateAll() if the designated constraints aren't met.
type ExitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitRequestMultiError) AllErrors() []error { return m }

// ExitRequestValidationError is the validation error returned by
// ExitRequest.Validate if the designated constraints aren't met.
type ExitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitRequestValidationError) ErrorName() string { return "ExitRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitRequestValidationError{}

// Validate checks the field values on ExitResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExitResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExitResponseMultiError, or
// nil if none found.
func (m *ExitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ExitResponseMultiError(errors)
	}

	return nil
}

// ExitResponseMultiError is an error wrapping multiple validation errors
// returned by ExitResponse.ValidateAll() if the designated constraints aren't met.
type ExitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExitResponseMultiError) AllErrors() []error { return m }

// ExitResponseValidationError is the validation error returned by
// ExitResponse.Validate if the designated constraints aren't met.
type ExitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExitResponseValidationError) ErrorName() string { return "ExitResponseValidationError" }

// Error satisfies the builtin error interface
func (e ExitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExitResponseValidationError{}

// Validate checks the field values on PropertyUpdate_PropertyValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PropertyUpdate_PropertyValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyUpdate_PropertyValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PropertyUpdate_PropertyValueMultiError, or nil if none found.
func (m *PropertyUpdate_PropertyValue) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyUpdate_PropertyValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Value.(type) {
	case *PropertyUpdate_PropertyValue_IntValue:
		if v == nil {
			err := PropertyUpdate_PropertyValueValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IntValue
	case *PropertyUpdate_PropertyValue_FloatValue:
		if v == nil {
			err := PropertyUpdate_PropertyValueValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for FloatValue
	case *PropertyUpdate_PropertyValue_StringValue:
		if v == nil {
			err := PropertyUpdate_PropertyValueValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for StringValue
	case *PropertyUpdate_PropertyValue_StateValue:
		if v == nil {
			err := PropertyUpdate_PropertyValueValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for StateValue
	case *PropertyUpdate_PropertyValue_LongValue:
		if v == nil {
			err := PropertyUpdate_PropertyValueValidationError{
				field:  "Value",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for LongValue
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PropertyUpdate_PropertyValueMultiError(errors)
	}

	return nil
}

// PropertyUpdate_PropertyValueMultiError is an error wrapping multiple
// validation errors returned by PropertyUpdate_PropertyValue.ValidateAll() if
// the designated constraints aren't met.
type PropertyUpdate_PropertyValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyUpdate_PropertyValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyUpdate_PropertyValueMultiError) AllErrors() []error { return m }

// PropertyUpdate_PropertyValueValidationError is the validation error returned
// by PropertyUpdate_PropertyValue.Validate if the designated constraints
// aren't met.
type PropertyUpdate_PropertyValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyUpdate_PropertyValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyUpdate_PropertyValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyUpdate_PropertyValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyUpdate_PropertyValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyUpdate_PropertyValueValidationError) ErrorName() string {
	return "PropertyUpdate_PropertyValueValidationError"
}

// Error satisfies the builtin error interface
func (e PropertyUpdate_PropertyValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyUpdate_PropertyValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyUpdate_PropertyValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyUpdate_PropertyValueValidationError{}
